#!/usr/bin/env python

# This file was generated automatically from conda-smithy. To update this configuration,
# update the conda-forge.yml and/or the recipe/meta.yaml.
try:
    from ruamel_yaml import safe_load, safe_dump
except ImportError:
    from yaml import safe_load, safe_dump
import os
import subprocess
import json
import argparse

global_config = json.loads('''
{{ channels | tojson }}''')
call = subprocess.check_call


def setup_conda_rc(args):
    specific_config = safe_load(open(args.config_file))
    if 'channel_sources' in specific_config:
        # Due to rendering we may have more than one row for channel_sources, if nothing gets zipped with it
        first_row = specific_config['channel_sources'][0]  # type: str
        channels = [c.strip() for c in first_row.split(',')]
    else:
        channels = global_config['sources']

    call(['conda', 'config', '--remove', 'channels', 'defaults'])
    for c in reversed(channels):
        call(['conda', 'config', '--add', 'channels', c])

    call(['conda', 'config', '--set', 'show_channel_urls', 'true'])


def upload_package(args):
    specific_config = safe_load(open(args.config_file))
    if 'channel_targets' in specific_config:
        channels = [c.strip().split(' ') for c in specific_config['channel_targets']]
    else:
        channels = global_config['targets']

    for owner, channel in channels:
        call(['{{ upload_script }}', args.recipe_root, owner, '--channel=%s' % channel, '-m', args.config_file])


def make_build_number(args):
    """
    General logic

        The purpose of this is to ensure that the new compilers have build
        numbers > 1000 and legacy compilers have a build number < 1000.

        This is done by reading the build_number_decrement which is rendered
        into all the recipes.

        For linux and osx we want to avoid building for the legacy compilers
        with build numbers > 1000

    Example matrix
        - {'compiler_c': 'toolchain_c', 'build_number_decrement': 1000}
        - {'compiler_c': 'gcc',         'build_number_decrement': 0}

    """
    specific_config = safe_load(open(args.config_file))
    build_number_dec = int(specific_config.get("build_number_decrement", [0])[0])

    use_legacy_compilers = False
    for key in {'c_compiler', 'cxx_compiler', 'fortran_compiler'}:
        if 'toolchain_' in specific_config.get(key, ''):
            use_legacy_compilers = True
            break

    import conda_build.api
    rendered_recipe = conda_build.api.render(recipe_path=args.recipe_root, variants=args.config_file)
    build_numbers = set()
    for recipe, _, _ in rendered_recipe:
        build_numbers.add(recipe.get_value('build/number'))
    if len(build_numbers) > 1:
        raise ValueError("More than one build number found, giving up")
    try:
        build_number_int = int(build_numbers.pop())

        if build_number_int < 1000:
            if not use_legacy_compilers:
                raise ValueError("Only legacy compilers only valid with build numbers < 1000")
            new_build_number = build_number_int
        else:
            new_build_number = build_number_int - build_number_dec

        config_dir, filename = os.path.split(args.config_file)
        with open(os.path.join(config_dir, 'clobber_' + filename), 'w') as fo:
            safe_dump({'build': {'number': new_build_number}}, fo)
    except ValueError:
        # This is a NON string build number
        # we have this for things like the blas mutex and a few other similar cases
        pass


def make_build_number(args):
    """
    General logic

        The purpose of this is to ensure that the new compilers have build
        numbers > 1000 and legacy compilers have a build number < 1000.

        This is done by reading the build_number_decrement which is rendered
        into all the recipes.

        For linux and osx we want to avoid building for the legacy compilers
        with build numbers > 1000

    Example matrix
        - {'compiler_c': 'toolchain_c', 'build_number_decrement': 1000}
        - {'compiler_c': 'gcc',         'build_number_decrement': 0}

    """
    specific_config = safe_load(open(args.config_file))
    build_number_dec = int(specific_config.get("build_number_decrement", [0])[0])
    # specialized compilers

    use_legacy_compilers = False
    for key in {'c_compiler', 'cxx_compiler', 'fortran_compiler'}:
        if 'toolchain_' in specific_config.get(key, ''):
            use_legacy_compilers = True
            break

    # nothing to do here
    if build_number_dec == 0:
        return

    import re
    recipe_dst = []
    build_number_found = False
    # Since recipes can contain build numbers in different outputs we have to do this gross part
    with open(os.path.join(args.recipe_root, 'meta.yaml')) as recipe_src:
        pat = re.compile("(\s*number\s*:\s*)(\d+)")
        for line in recipe_src.readlines():
            match = pat.match(line)
            if match:
                prefix, suffix = match.groups()
                orig_build_number = int(suffix)
                if (orig_build_number < 1000):
                    if not use_legacy_compilers:
                        raise ValueError("Only legacy compilers only valid with build numbers < 1000")
                    else:
                        # keep original build number
                        line = line
                else:
                    line = prefix + str(orig_build_number - build_number_dec) + '\n'
                build_number_found = True
            recipe_dst.append(line)

    if build_number_found:
        with open(os.path.join(args.recipe_root, 'meta.yaml'), 'w') as fo:
            fo.writelines(recipe_dst)
    else:
        # conda build ignores clobber files that don't exist, so this is safe
        config_dir, filename = os.path.split(args.config_file)
        with open(os.path.join(config_dir, 'clobber_' + filename), 'w') as fo:
            safe_dump({'build': {'number': 1000 - build_number_dec}}, fo)


def mangle_compiler(args):
    """Try hard to break the compilers for osx"""
    # TODO


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    setup_conda_rc_parse = subparsers.add_parser('setup_conda')
    setup_conda_rc_parse.add_argument("config_file")
    setup_conda_rc_parse.set_defaults(function=setup_conda_rc)

    upload_package_parse = subparsers.add_parser('upload_package')
    upload_package_parse.add_argument("recipe_root")
    upload_package_parse.add_argument("config_file")
    upload_package_parse.set_defaults(function=upload_package)

    make_build_number_parse = subparsers.add_parser('make_build_number')
    make_build_number_parse.add_argument("recipe_root")
    make_build_number_parse.add_argument("config_file")
    make_build_number_parse.set_defaults(function=make_build_number)

    mangle_compiler_parse = subparsers.add_parser('mangle_compiler')
    mangle_compiler_parse.add_argument("config_file")
    mangle_compiler_parse.set_defaults(function=mangle_compiler)

    args = parser.parse_args()
    args.function(args)